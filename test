1      常用数据结构

1.1      线性表

一个线性表是n个具有相同特性的数据元素的有限序列。线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（部分链表除外）。

线性表主要由顺序表示或链式表示。在实际应用中，常以栈、队列、字符串、链表等特殊形式使用。

1.1.1        数组

顺序表是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。

二分搜索算法：

二分搜索是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。二分搜索在情况下的复杂度是对数时间，进行O(log n)次比较操作。

二分搜索有许多中变种。比如分散层叠可以提升在多个数组中对同一个数值的搜索。分散层叠有效的解决了计算几何学和其他领域的许多搜索问题。指数搜索将二分搜索拓宽到无边界的列表。二分搜索树和B树数据结构就是基于二分搜索的。

示例代码如下：

int Method(int[] nums, int low, int high, int target) {

            while (low <= high) {

                int middle = low + (high – low) / 2;     // 这里不用(high+low)/2是为了防止溢出

                if (target == nums[middle]) {

                    return middle;

                }

                else if (target > nums[middle]) {

                    low = middle + 1;

                }

                else if (target < nums[middle]) {

                    high = middle - 1;

                }

            }

            return -1;

        }

1.1.2        单向链表

链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值（NULL）。

                                                  

单向链表的存储表示：

   

单向链表的插入操作：

（1）若原链表为空，则将新建节点p作为头节点，让head指向新节点p

（2）若原链表为非空，折按新建节点的值的大小（假设原链表已按节点值升序排列）确定插入新节点的位置。若在头结点前插入新节点，则将新节点的指针域指向原链表的头结点，并且让head指向新节点p

（3）若在原链表中间插入新节点，则将新节点p的指针域指向下一节点，并且让前一节点的指针域指向新建节点p

（4）若在表尾插入新节点，则将尾节点的指针域指向新节点p

单向链表的删除操作：

（1）若原链表为空，则不执行任何操作，直接退出程序

（2）若待删除节点是头节点，则将head指向当前节点的下一个节点，再删除当前节点

（3）若待删除节点不是头节点，则将前一节点的指针域指向当前节点的下一节点，即可删除当前节点。当待删除节点是尾节点时，由于p->next=NULL，因此执行pr->next = p->next后，pr->next的值也变为了NULL，从而使pr所指向的节点由倒数第二个节点变成尾节点。

（4）如果节点内数据指针内存需要释放，在删除操作后，需要释放节点数据指针的内存

扩展：如何判定单链表存在回环？？？

参考 -  判断单链表是否存在回环原理很简单，即假设有两个指针p1，p2。在每次循环的时候，p1先走一步，p2走两步，直到p2碰到空指针或两者相等时循环结束，如果两个指针相等则说明存在回环。

1.1.3        双向链表

双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针。所以在双向链表中的结点都有两个指针域：一个指向直接后继，一个指向直接前驱。

   

双向链表表示方法：

   

双向链表操作：

双向链表是单链表扩展出来的结构，所以它的很多操作是和单链表相同的，比如求长度的ListLength,查找元素的GetElem,获得元素位置的LocateElem等，这些操作都只要涉及一个方向的指针即可。

相对于单链表而言，删除和插入操作基本步骤也是类似的。只是与单链表不同，双链表要额外注意前指针的处理。

1.1.4        跳表

跳表(skip list) 对标的是平衡树(AVL Tree)，是一种 插入/删除/搜索 都是 O(log n) 的数据结构。它最大的优势是原理简单、容易实现、方便扩展、效率更高。因此在一些热门的项目里用来替代平衡树，如 redis, leveldb 等。

顺序存储的数据，使用链表组织的示意图如下：

   

这个链表中，如果要搜索一个数或将一个数按照顺序插入到合适的位置，需要逐个节点进行搜索与比较，直到找到匹配的数为止。即时间复杂度为O(n)。

而跳表的思想是，如果能够将下一跳的指针，指向更远的节点，而非紧邻的下一个节点，就能够实现快速的跳跃，节省遍历次数。

   

最下面一层编号为0，依次往上。每个节点的层数是随机的，随机分布概率与2的幂成正比，随机到K(K>=0)层的概率为1/(2^k)。第0层组成了一个顺序存储的链表。

假设我们在上图中要查找数为17的节点，首先从最高层（第三层）找到第一跳，节点数据为21（大于17）。因此退化到从第二层开始找，找到第一跳节点数据为9，然后下一跳找到正确节点21。

如果是寻找数据25的节点，效率更高，从最上面一层直接找到21，然后下一跳可以找到25。

1.1.5        栈

栈是一种只允许在一端插入和删除的线性表。允许插入和删除的一端称为栈顶（TOP），另一端称为栈底（BOTTOM）。栈的特点是后进先出。

栈中的每个元素称为一个frame。而最上层元素称为top frame。栈只支持三个操作： pop, top, push。

   

由于栈是限定了操作的有序的元素集合，所以我们既可以在数组的基础上来实现栈，也可以在表的基础上来实现栈。如果使用数组来实现栈，我们需要预留充足的空间供栈使用，并需要一个下标来记录最上层元素的位置。

栈应用实例：十进制数转换为二进制

假设要讲十进制转换为二进制。以 52 为例，如图：

   

在上述计算过程中，第一次求出的X值为最低位，最后一次求出的X值为最高位。而打印时应从高位到低位进行，恰好与计算过程相反。根据这个特点，我们可以通过入栈出栈来实现，即将计算过程中依次得到的二进制数码按顺序进栈，计算结束后，再顺序出栈，并按出栈顺序打印输出。即可得到给定的二进制数。

   

使用栈还可以用于诸如计算器，图的遍历等。

1.1.6        队列

队列是一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列是一个先进先出的线性表。

   

同栈的实现一样，队列的实现也有数组实现和链表实现两种方式。

数组表示方法：

   

链表表示：

   

队列应用举例：进程间通信

消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。  每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。

对于系统中的每个消息队列，内核维护一个定义在<sys/msg.h>头文件中的消息队列结构。

    struct msqid_ds {
    

        struct ipc_perm msg_perm ;
    

        struct msg*    msg_first ; //指向队列中的第一个消息
    

        struct msg*    msg_last ; //指向队列中的最后一个消息
    

        ...
    

    };
    

 

Linux 中还提供了一系列消息队列的函数接口来让我们方便地使用它来实现进程间的通信

// 创建和访问一个消息队列

int msgget(key_t key, int msgflg);  

// 该函数用来把消息添加到消息队列中

int msgsnd(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);  

// 该函数用来从一个消息队列获取消息

int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg);  

// 该函数用来控制消息队列

int msgctl(int msgid, int command, struct msgid_ds *buf);  

 

1.1.7        练习题目

重复N次的元素<数组>：https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/

两数相加<链表>：https://leetcode-cn.com/problems/add-two-numbers/

基本计算器<栈>：https://leetcode-cn.com/problems/basic-calculator/

设计循环队列<队列>：https://leetcode-cn.com/problems/design-circular-queue/

1.2      哈希表

哈希表又称散列表，其基本思想是：

以数据表中的每个记录的关键字k通过一种函数H(k)计算出函数值。把这个值解释为一块连续存储空间（即数组空间）的单元地址（即下标），将该记录存储到这个单元中。在此称该函数H为哈希函数或散列函数。按这种方法建立的表称为哈希表或散列表。查找时，通过H(K)直接定位到元素存储位置，实现高速查找。

例如：要将关键字值序列（3，15，22，24），存储到编号为0到4的表长为5的哈希表中。计算存储地址的哈希函数可取除5的取余数算法H(k)=k % 5。则构造好的哈希表如图所示。

 

   

1.2.1        哈希函数设计方法：

l  直接地址法

对于关键字是整数类型的数据，直接地址的哈希函数H直接利用关键字求的哈希地址。H(Ki)=aKi+b， (a，b为常量)

l  数字分析法

假设有一组关键字，每个关键字由几位数字组成，如K1 K2 K3...Kn。是从中提取数字分布比较均匀的若干位作为哈希地址。

例如：对于关键字k1到k8的序列{100011211 100011322 100011413 100011556 100011613 100011756 100011822 100011911} ，可以取第6和第7位作为哈希地址， H(K1)=12 H(K2)=13 H(K3)=14 H(K4)=15 H(K5)=16 H(K6)=17 H(K7)=18 H(K8)=19 。

l  平方取中法

取关键字平方的中间几位作为散列地址的方法，具体取多少位看情况，即：H(Ki)=“Ki的平方的中间几位“这也是常用的较好的设计哈希函数的方法。关键字平方后使得它的中间几位和组成关键字的多位值均有关，从而使哈希地址的分布更为均匀，减少冲突的可能性。

l  折叠法

首先把关键字分割成位数相同的几段（最后一段位数可少些），段的位数取决于哈希地址的位数，由实际情况而定，然后将他们叠加和（舍去最高进位）作为哈希地址的方法。与平方取中法类似，折叠法也使得关键字的各位值都对哈希地址产生影响。

l  除留余数法

关键字Ki处以一个合适的不大于哈希表长度的正整数P，所得余数作为哈希地址的方法。对应哈希函数：H(K )=K MOD P 这里的mod表示求余数运算，用该方法产生的哈希函数的好坏取决P值的选取。实践证明，当P取小于哈希表长的最大质数时，产生的哈希函数较好。是一种简单而行之有效的构造方法。

1.2.2        哈希冲突：

理想情况下，哈希函数在关键字和地址之间建立了一个一一对应关系，从而使得查找只需一次计算即可完成。但由于关键字值的某种随机性，使得这种一一对应关系难以发现或构造，因而可能会出现不同的关键字对应一个存储地址。即k1≠k2，但H(k1)=H(k2)，这种现象称为冲突。 此外，可能关键字的集合比较大，而对应的连续空间较少。

因此在大多数情况下，冲突是不能完全避免的。

解决哈希冲突常用方法： 链地址法

链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。

   

1.2.3        练习题目

设计哈希集合：https://leetcode-cn.com/problems/design-hashset/

设计哈希映射：https://leetcode-cn.com/problems/design-hashmap/

根据字符出现频率排序：https://leetcode-cn.com/problems/sort-characters-by-frequency/solution/

1.3      树与二叉树

树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

 

l  每个节点都只有有限个子节点或无子节点；

l  没有父节点的节点称为根节点；

l  每一个非根节点有且只有一个父节点；

l  除了根节点外，每个子节点可以分为多个不相交的子树；

l  树里面没有环路(cycle)

   

1.3.1        一些术语

l  节点的度：一个节点含有的子树的个数称为该节点的度；

l  树的度：一棵树中，最大的节点度称为树的度；

l  叶节点或终端节点：度为零的节点；

l  非终端节点或分支节点：度不为零的节点；

l  父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；

l  孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；

l  兄弟节点：具有相同父节点的节点互称为兄弟节点；

l  节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；

l  深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；

l  高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；

l  堂兄弟节点：父节点在同一层的节点互为堂兄弟；

l  节点的祖先：从根到该节点所经分支上的所有节点；

l  子孙：以某节点为根的子树中任一节点都称为该节点的子孙。

l  森林：由m（m>=0）棵互不相交的树的集合称为森林；

1.3.2        树的种类

·         无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；

·         有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；

o    二叉树：每个节点最多含有两个子树的树称为二叉树；

§  完全二叉树：对于一颗二叉树，假设其深度为d（d>1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；

§  满二叉树：所有叶节点都在最底层的完全二叉树；

§  平衡二叉树（AVL树**）：**当且仅当任何节点的两棵子树的高度差不大于1的二叉树；

§  排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树；

o    霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；

o    B**树**：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。

 

  二叉树             	二叉查找树（BST） 笛卡尔树    MVP树  Top tree   T树  
  自平衡二叉查找树        	AA树 AVL树  左倾红黑树 红黑树 替罪羊树 伸展树 树堆 加权平衡树   
  B树              	·           B+树 B*树   Bx树   UB树   2-3树 2-3-4树 (a,b)-树   Dancing   tree H树
  堆               	二叉堆 二项堆  斐波那契堆  左偏树 配对堆 斜堆 Van Emde   Boas tree
  Trie            	·           后缀树 基数树 三叉查找树 X-快速前缀树   Y-快速前缀树   AC自动机
  二叉空间分割（BSP）**树**	·           四叉树 八叉树 k-d树   隐式k-d树 VP树   
  非二叉树            	·           指数树 融合树 区间树  PQ树   Range tree   SPQR树
  空间**数据分割树**     	·           R树 R*树  R+树 X树   M树   线段树 可持久化线段树 希尔伯特R树 优先R树
  其他树             	·           散列日历 散列树 Finger tree   顺序统计树 Metric tree   Cover tree   BK树   Doubly   chained tree iDistance   Link-cut   tree Log-structured   merge-tree 树状数组 哈希树(Merkle tree)

1.3.3        二叉树

简单地理解，满足以下两个条件的树就是二叉树：

l  本身是有序树；

l  树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；

例如，图 1a) 就是一棵二叉树，而图 1b) 则不是。

 图 1 二叉树示意图

二叉树具有以下几个性质：

l  二叉树中，第 i 层最多有 2i-1个结点。

l  如果二叉树的深度为 K，那么此二叉树最多有 2K-1个结点。

l  二叉树中，终端结点数（叶子结点数）为  n0，度为 2 的结点数为  n2，则  n0=n2+1。

满二叉树

如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。

 图 2 满二叉树示意图

l  满二叉树除了满足普通二叉树的性质，还具有以下性质：

l  满二叉树中第 i 层的节点数为 2^(i-1) 个。

l  深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。

l  满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。

l  具有 n 个节点的满二叉树的深度为 log2(n+1)。

完全二叉树

如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。

 图 3 完全二叉树示意图

完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。

⌊log2n⌋ 表示取小于 log2n 的最大整数。例如，⌊log24⌋ = 2，而 ⌊log25⌋ 结果也是 2。

对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：

l  当 i>1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）

l  如果 2i>n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2i 。

l  如果 2i+1>n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2i+1 。

二叉树的遍历：

l  先序遍历

二叉树先序遍历的实现思想是：

1.         访问根节点；

2.         访问当前节点的左子树；

3.         若当前节点无左子树，则访问当前节点的右子树；

l  中序遍历

二叉树中序遍历的实现思想是：

1.         访问当前节点的左子树；

2.         访问根节点；

3.         访问当前节点的右子树；

l  后序遍历

二叉树后序遍历的实现思想是：

1.         访问当前节点的左子树；

2.         访问当前节点的右子树；

3.         访问根节点；

l  层次遍历

按照二叉树中的层次从左到右依次遍历每层中的结点。具体的实现思路是：通过使用队列的数据结构，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果。

   

上述二叉树三种遍历方式的结果：

先序遍历：1 2 4 5 3 6 7

中序遍历：4 2 5 1 6 3 7

后序遍历：4 5 2 6 7 3 1

层次遍历：1 2 3 4 5 6 7

1.3.4        二叉查找树

二叉查找树也称为二叉搜索树、有序二叉树或排序二叉树，是指一棵空树或者具有下列性质的二叉树：

l  若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；

l  若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；

l  任意节点的左、右子树也分别为二叉查找树；

l  没有键值相等的节点。

   

上图两个二叉树表示, 二叉树（b）是一个二叉查找树（BST），它符合二叉查找树的性质规定。而二叉树（a），则不是二叉查找树。因为节点 10 的右孩子节点 8 小于节点 10，但却出现在节点 10 的右子树中。

二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低O(log n)**。搜索、插入、删除的复杂度等于树高，期望O(log n)，最坏 O(n)（数列有序，树退化成线性表）。**

虽然二叉查找树的最坏效率是 O(n)，但它支持动态查询，且有很多改进版的二叉查找树可以使树高为O(log n)，从而将最坏效率降至O(log n)，如AVL树、红黑树等。

查找算法：

1.      若b是空树，则搜索失败，否则：

2.      若x等于b的根节点的数据域之值，则查找成功；否则：

3.      若x小于b的根节点的数据域之值，则搜索左子树；否则：

4.      查找右子树。

插入算法：

1.      若b是空树，则将s所指节点作为根节点插入，否则：

2.      若s->data等于b的根节点的数据域之值，则返回，否则：

3.      若s->data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：-> 4

4.      把s所指节点插入到右子树中。（新插入节点总是叶子节点）

删除算法：

1.      若*p结点为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。

2.      若p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树（当p是左子树）或右子树（当p是右子树）即可，作此修改也不破坏二叉查找树的特性。

3.      若p结点的左子树和右子树均不空。在删去p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：其一是令p的左子树为f的左/右（依p是f的左子树还是右子树而定）子树，s为p左子树的最右下的结点，而p的右子树为s的右子树；其二是令p的直接前驱（in-order predecessor）或直接后继（in-order successor）替代p，然后再从二叉查找树中删去它的直接前驱（或直接后继）。

1.3.5        平衡树

平衡树是一类改进的二叉查找树。一般的二叉查找树的查询复杂度是跟目标结点到树根的距离（即深度）有关，因此当结点的深度普遍较大时，查询的均摊复杂度会上升，为了更高效的查询，平衡树应运而生了。

   

在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。

几乎所有平衡树的操作都基于树旋转操作，通过旋转操作可以使得树趋于平衡。 对一棵查找树（search tree）进行查询、新增、删除等动作，所花的时间与树的高度h成比例，并不与树的容量 n 成比例。如果可以让树维持矮矮胖胖的好身材，也就是让h维持在 O(logn)的左右，完成上述工作就很省时间。能够一直维持好身材，不因新增删除而长歪的搜寻树，叫做平衡树（balanced search tree）。

AVL**树**

在AVL**树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树**。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。

节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。

高度为h*的AVL树，总节点数N最多2^h -1；**当节点数为N时，高度h最多为{\displaystyle log_{\Phi }({\sqrt {5}}(N+1))-2}   

 

红黑树

红黑树（英语：Red–black tree）是一种自平衡二叉查找树，典型的用途是实现关联数组。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在O(log n) 时间内完成查找，插入和删除，这里的n是树中元素的数目。

红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。

红黑树与**AVL树的对比：**

l  AVL树在插入、删除结点时要把树调整到完全平衡，红黑树只要调整到大致平衡，因此通常红黑树的插入、删除结点性能稍好。

l  AVL的查找性能通常比红黑树要好。

l  如果结点的增删操作远小于查找操作，则应选择AVL；反之，红黑树可能更好。

红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

1.    节点是红色或黑色。

2.    根是黑色。

3.    所有叶子都是黑色（叶子是NIL节点）。

4.    每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）

5.    从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

下面是一个具体的红黑树的图例：

     

这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

B+**树**

B+ 树通常用于数据库和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。

B+ 背后的想法是内部节点可以有在预定范围内的可变量目的子节点。因此，B+ 树不需要像其他自平衡二叉查找树那样经常的重新平衡。对于特定的实现在子节点数目上的低和高边界是固定的。例如，在 2-3 B 树（常简称为2-3 树）中，每个内部节点只可能有 2 或 3 个子节点。如果节点有无效数目的子节点则被当作处于违规状态。

   

1.3.6        堆树

堆（heap）也被称为优先队列（**priority queue）。堆遵守队列操作模式，在堆底插入元素，在堆顶取出元素，但是堆中元素的排列不是按照到来的先后顺序，而是按照一定的优先顺序排列的**。

堆的本质是一个完全二叉树，所以可以考虑使用二叉树的表示方法来表示堆。但是因为堆中元素按照一定的优先顺序排列，因此可以使用更简单的方法——数组——来表示，这样可以节省子节点指针空间，并且可以快速访问每个节点。堆得数组表示其实就是堆层级遍历的结果。

堆的特性：

l  必须是完全二叉树

l  用数组实现

l  任一结点的值是其子树所有结点的最大值或最小值

u  最大值时，称为“最大堆”，也称大顶堆；

u  最小值时，称为“最小堆”，也称小顶堆。

   

图一表示了一个最大堆，图二表示了一个最小堆。

堆不能保证整棵树都是有序的，在二叉树中搜索很快，但是在堆中的搜索很慢。在堆中，搜索不是第一优先级，因为使用堆的目的是将最大（或最小）的节点放在最前面，从而快速进行相关插入、删除操作。

堆中的插入和删除操作时间复杂度为O(**log2n)。**

1.3.7        练习题目

先序遍历构造二叉树：https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/

从中序与后序遍历构造二叉树：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

二叉树的层次遍历：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

从二叉搜索树到更大和树：https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/

二叉搜索树的最近公共祖先：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

前K个高频单词<堆>：https://leetcode-cn.com/problems/top-k-frequent-words/
