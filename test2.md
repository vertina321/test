1.4      图

图（Graph）是由顶点的有穷非空集合和顶点之间的边的集合组成，通常

表示为： G(V,E)。其中，G 表示一个图，V 是图 G 中顶点的集合，E 是

图 G 中边的集合。

1.4.1        基础知识

图是由顶点和边组成的：(可以无边，但至少包含一个顶点)

l  一组顶点：通常用 V(vertex) 表示顶点集合

l  一组边：通常用 E(edge) 表示边的集合

图可以分为有向图和无向图，在图中：

l  (v, w) 表示无向边，即 v 和 w 是互通的

l  <v, w> 表示有向边，该边始于 v，终于 w

图可以分为有权图和无权图：

l  有权图：每条边具有一定的权重(weight)，通常是一个数字

l  无权图：每条边均没有权重，也可以理解为权为 1

图又可以分为连通图和非连通图：

l  连通图：所有的点都有路径相连

l  非连通图：存在某两个点没有路径相连

l  强连通图：在有向图中, 若对于每一对顶点vi和vj, 都存在一条从vi到vj和从vj到vi的路径, 则称此图是强连通图。

图中的顶点有度的概念：

l  度(Degree)：所有与它连接点的个数之和

l  入度(Indegree)：存在于有向图中，所有接入该点的边数之和

l  出度(Outdegree)：存在于有向图中，所有接出该点的边数之和

图的路径：

l  路径：若从顶点 vi 出发, 沿一些边经过若干顶点 vp1, vp2, …, vpm，到达顶点vj，则称顶点序列 (vi , vp1 , vp2 , ... , vpm , vj) 为从顶点vi 到顶点 vj 的一条路径。

l  路径长度：非带权图的路径长度是指此路径上边的条数。带权图的路径长度是指路径上各边的权值之和。

l  简单路径：若路径上各顶点 v1, v2, ..., vm 均不互相重复, 则称这样的路径为简单路径。

l  回路：若路径上第一个顶点 v1 与最后一个顶点vm 重合, 则称这样的路径为回路或环。

1.4.2        图的表示

邻接矩阵表示（**Adjacency Matrix）**

l  在 n 个顶点的图需要有一个 n × n 大小的矩阵

l  在一个无权图中，矩阵坐标中每个位置值为 1 代表两个点是相连的，0 表示两点是不相连的

l  在一个有权图中，矩阵坐标中每个位置值代表该两点之间的权重，0 表示该两点不相连

l  在无向图中，邻接矩阵关于对角线相等

邻接链表表示（**Adjacency List）**

l  对于每个点，存储着一个链表，用来指向所有与该点直接相连的点

l  对于有权图来说，链表中元素值对应着权重

   

无向图表示方法

   

有向图表示方法

1.4.3        图的遍历

深度优先遍历：**(Depth First Search, DFS)**

基本思路：深度优先遍历图的方法是，从图中某顶点 v 出发

1.       访问顶点 v

2.       从 v 的未被访问的邻接点中选取一个顶点 w，从 w 出发进行深度优先遍历

3.       重复上述两步，直至图中所有和v有路径相通的顶点都被访问到

伪码实现：

//**伪码实现，类似于树的先序遍历

public void DFS**(Vertex v){**

    visited[v] = true;

    for(v 的每个邻接点 W){

         if(!visited[W]){

             DFS(W);

         }

    }

}

 

广度优先搜索：**(Breadth First Search, BFS)**

广度优先搜索，可以被形象地描述为 "浅尝辄止"，它也需要一个队列以保持遍历过的顶点顺序，以便按出队的顺序再去访问这些顶点的邻接顶点。 

实现思路：

1.  顶点 v 入队列

2.  当队列非空时则继续执行，否则算法结束

3.  出队列取得队头顶点 v；访问顶点 v 并标记顶点 v 已被访问

4.  查找顶点 v 的第一个邻接顶点 col

5.  若 v 的邻接顶点 col 未被访问过的，则 col 继续

6.  查找顶点 v 的另一个新的邻接顶点 col，转到步骤 5 入队列，直到顶点 v 的所有未被访问过的邻接点处理完。转到步骤 2

使用深度优先搜索与广度优先搜索，时间复杂度都为O(n^2)。

要理解深度优先和广度优先搜索，首先要理解搜索步，一个完整的搜索步包括两个处理 

l  获得当前位置上，有几条路可供选择

l  根据选择策略，选择其中一条路，并走到下个位置

相当于在漆黑的夜里，你只能看清你站的位置和你前面的路，但你不知道每条路能够通向哪里。搜索的任务就是，给出初始位置和目标位置，要求找到一条到达目标的路径。 

深度优先就是，从初始点出发，不断向前走，如果碰到死路了，就往回走一步，尝试另一条路，直到发现了目标位置。这种不撞南墙不回头的方法，即使成功也不一定找到一条好路，但好处是需要记住的位置比较少。

广度优先就是，从初始点出发，把所有可能的路径都走一遍，如果里面没有目标位置，则尝试把所有两步能够到的位置都走一遍，看有没有目标位置；如果还不行，则尝试所有三步可以到的位置。这种方法，一定可以找到一条最短路径，但需要记忆的内容实在很多，要量力而行。

1.4.4        最短路径

迪杰斯特拉 Dijkstra 算法：

Dijkstra 算法适用于权值为正的的图

Dijkstra 算法属于单源算法，即只能求出某点到其它点最短距离，并不能得出任意两点之间的最短距离。

在源点可达的情况下，**Dijkstra算法的时间复杂度**是O(ElogV)。

算法步骤：

1.       将所有边初始化为无穷大

2.       选择一个开始的顶点，添加到优先队列中

3.       对于该点的所有邻接顶点进行判断，如果到该点的距离小于原先的值，则将该值进行更新

4.       将该点所有邻接顶点添加到优先队列中

5.       从优先队列中挑选出一个路径值最小的顶点，将其弹出，作为新的顶点，重复步骤 3，4，5

6.       直到所有点都被处理过一次

佛洛伊德 Floyd 算法： 

Floyd 算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点 i 到点 j 的最短路径。

Floyd**算法可以求出任意两点的最短距离。时间复杂度： O(n^3)。**

从任意节点 i 到任意节点 j 的最短路径不外乎 2 种可能：

1.       是直接从 i 到 j

2.       是从 i 经过若干个节点 k 到 j

所以，我们假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离，对于每一个节点 k，我们检查Dis(i,k) + Dis(k,j) < Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到 j 的路径短，我们便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离。

 

for(**int** k=0; k<n; k++) { 

    for(i=0; i<n; i++) {

         for(j=0; j<n; j++)

             if(A[i][j]>(A[i][k]+A[k][j])) {

                  A[i][j]=A[i][k]+A[k][j];

                  path[i][j]=k;

             } 

    }

} 

1.4.5        拓扑排序

在图论中，拓扑排序（**Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列**。且该序列必须满足下面两个条件：

l  每个顶点出现且只出现一次。

l  若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。

有向无环图（DAG**）才有拓扑排序，非DAG图没有拓扑排序一说。**

例如，下面这个图：

   

它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：

l  从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。

l  从图中删除该顶点和所有以它为起点的有向边。

l  重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。

   

于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。

1.4.6        练习题目

判断二分图：https://leetcode-cn.com/problems/is-graph-bipartite/

克隆图：https://leetcode-cn.com/problems/clone-graph/

找到小镇的法官：https://leetcode-cn.com/problems/find-the-town-judge/

钥匙和房间：https://leetcode-cn.com/problems/keys-and-rooms/

最短路径访问所有节点：https://leetcode.com/problems/shortest-path-visiting-all-nodes/



